---
// ReadingProgressBar.astro
// A minimal reading progress bar that shows how much content is left to read
---

<div id="reading-progress-container" class="reading-progress-container">
  <div id="reading-progress-bar" class="reading-progress-bar"></div>
  <div id="reading-progress-text" class="reading-progress-text">0% read</div>
</div>

<!-- Alternative: Circular Progress (uncomment to use instead) -->
<!-- 
<div id="reading-progress-circle" class="reading-progress-circle">
  <svg class="progress-ring" width="60" height="60">
    <circle
      class="progress-ring-bg"
      stroke="var(--border)"
      stroke-width="3"
      fill="transparent"
      r="26"
      cx="30"
      cy="30"/>
    <circle
      class="progress-ring-progress"
      stroke="var(--accent)"
      stroke-width="3"
      fill="transparent"
      r="26"
      cx="30"
      cy="30"
      stroke-dasharray="163.36"
      stroke-dashoffset="163.36"/>
  </svg>
  <div class="progress-text">0%</div>
</div>
-->

<script>
  class ReadingProgress {
    private progressBar: HTMLElement | null = null;
    private progressText: HTMLElement | null = null;
    private container: HTMLElement | null = null;
    private isVisible: boolean = false;

    constructor() {
      this.init();
    }

    private init(): void {
      this.progressBar = document.getElementById("reading-progress-bar");
      this.progressText = document.getElementById("reading-progress-text");
      this.container = document.getElementById("reading-progress-container");

      if (!this.progressBar || !this.progressText || !this.container) return;

      this.updateProgress();
      window.addEventListener(
        "scroll",
        this.throttle(this.updateProgress.bind(this), 16),
      );
      window.addEventListener(
        "resize",
        this.throttle(this.updateProgress.bind(this), 100),
      );
    }

    private updateProgress(): void {
      if (!this.progressBar || !this.progressText || !this.container) return;

      const contentElement = document.querySelector(
        ".post-content",
      ) as HTMLElement;
      if (!contentElement) return;

      const viewportHeight = window.innerHeight;
      const contentHeight = contentElement.scrollHeight;
      const contentTop = contentElement.offsetTop;
      const scrollTop = window.pageYOffset;

      const isContentShort = contentHeight <= viewportHeight * 1.5;

      if (isContentShort) {
        if (this.isVisible) {
          this.container.classList.remove("visible");
          this.isVisible = false;
        }
        return;
      }

      const contentStart = contentTop - 100;
      const contentEnd = contentTop + contentHeight - viewportHeight;

      const shouldShow = scrollTop >= contentStart && contentEnd > contentStart;

      if (shouldShow && !this.isVisible) {
        this.container.classList.add("visible");
        this.isVisible = true;
      } else if (!shouldShow && this.isVisible) {
        this.container.classList.remove("visible");
        this.isVisible = false;
        return;
      }

      if (!this.isVisible) return;

      let progress = 0;
      if (scrollTop >= contentEnd) {
        progress = 100;
      } else if (scrollTop >= contentStart) {
        const scrollableDistance = contentEnd - contentStart;
        const scrolledDistance = scrollTop - contentStart;
        progress = (scrolledDistance / scrollableDistance) * 100;
      }

      progress = Math.max(0, Math.min(100, progress));
      this.progressBar.style.width = `${progress}%`;

      const progressPercent = Math.round(progress);
      this.progressText.textContent = `${progressPercent}%`;
    }

    private throttle(func: Function, delay: number): () => void {
      let timeoutId: ReturnType<typeof setTimeout>;
      let lastExecTime = 0;

      return () => {
        const currentTime = Date.now();
        if (currentTime - lastExecTime > delay) {
          func();
          lastExecTime = currentTime;
        } else {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(
            () => {
              func();
              lastExecTime = Date.now();
            },
            delay - (currentTime - lastExecTime),
          );
        }
      };
    }
  }

  document.addEventListener("astro:page-load", () => {
    new ReadingProgress();
  });
</script>

<style>
  .reading-progress-container {
    position: fixed;
    top: var(--header-height);
    left: 0;
    width: 100%;
    height: 3px;
    background: transparent;
    z-index: 110;
    opacity: 0;
    transform: translateY(-100%);
    transition: all var(--transition-speed) var(--transition-ease);
    pointer-events: none;
  }

  .reading-progress-container.visible {
    opacity: 1;
    transform: translateY(0);
  }

  .reading-progress-bar {
    height: 100%;
    background: var(--accent);
    transition: width 0.1s linear;
    min-width: 0;
    box-shadow: 0 0 8px var(--accent);
  }

  .reading-progress-text {
    position: absolute;
    right: var(--spacing-sm);
    top: 6px;
    font-size: 10px;
    font-weight: 700;
    color: var(--text-secondary);
    background: var(--glass-bg);
    padding: 2px 8px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    white-space: nowrap;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    opacity: 0.8;
  }

  @media (max-width: 768px) {
    .reading-progress-container {
      height: 2px;
    }
  }
</style>
